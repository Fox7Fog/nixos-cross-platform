package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Colors for output
const (
	ColorRed    = "\033[0;31m"
	ColorGreen  = "\033[0;32m"
	ColorYellow = "\033[1;33m"
	ColorBlue   = "\033[0;34m"
	ColorNC     = "\033[0m" // No Color

	// Configuration
	DefaultGithubRepo   = "fox7fog/nixos-cross-platform" // Updated from yourusername
	LocalFlakeDirName   = "nixos-cross-platform"
	DevFunctionsStartMarker = "# Dev Environment Functions (Go Version)"
	DevFunctionsEndMarker   = "# End Dev Environment Functions (Go Version)"
)

// devFunctionsTemplate is the string to be injected into shell configs.
// It uses %s as a placeholder for the flake_ref.
const devFunctionsTemplate = `
%s
# Generated by nixos-cross-platform installer (Go Version)

# Function to enter dev shells from anywhere
dev() {
    local shell_name=${1:-default}
    local flake_ref="%s"
    
    echo "üöÄ Entering $shell_name development shell..."
    echo "üìç Current directory: $(pwd)"
    echo "üîß Using flake: $flake_ref"
    
    nix develop "$flake_ref#$shell_name" --command $SHELL
}

# Specific shell aliases for convenience
alias dev-rust='dev web-rust'
alias dev-python='dev python'
alias dev-go='dev go'
alias dev-ethereum='dev ethereum'
alias dev-solana='dev solana'
alias dev-default='dev default'

# List available dev shells
dev-list() {
    echo "Available development shells:"
    echo "  ‚Ä¢ default     - Basic Nix development environment"
    echo "  ‚Ä¢ web-rust    - Rust web development (trunk, wasm-pack)"
    echo "  ‚Ä¢ python      - Python development environment"
    echo "  ‚Ä¢ go          - Go development environment"
    echo "  ‚Ä¢ ethereum    - Ethereum/Web3 TypeScript development"
    echo "  ‚Ä¢ solana      - Solana development environment"
    echo ""
    echo "Usage: dev <shell-name>"
    echo "   or: dev-<shell-name>"
}

# Update flake (useful for remote flakes)
dev-update() {
    local flake_ref="%s"
    echo "üîÑ Updating flake inputs..."
    nix flake update "$flake_ref"
}

# Quick shell info
dev-info() {
    local flake_ref="%s"
    echo "Dev Environment Info:"
    echo "  Flake: $flake_ref"
    echo "  Shell: $(basename $SHELL)"
    echo "  Current dir: $(pwd)"
}

%s
`


func printHeader() {
	fmt.Printf("%s=================================%s\n", ColorBlue, ColorNC)
	fmt.Printf("%s  Dev Environment Setup (Go)%s\n", ColorBlue, ColorNC)
	fmt.Printf("%s=================================%s\n", ColorBlue, ColorNC)
	fmt.Println()
}

func printSuccess(message string) {
	fmt.Printf("%s‚úì%s %s\n", ColorGreen, ColorNC, message)
}

func printWarning(message string) {
	fmt.Printf("%s‚ö†%s %s\n", ColorYellow, ColorNC, message)
}

func printError(message string) {
	fmt.Printf("%s‚úó%s %s\n", ColorRed, ColorNC, message)
}

func checkNix() bool {
	cmd := exec.Command("nix", "--version") // Simple command to check if nix exists
	if err := cmd.Run(); err != nil {
		printError("Nix is not installed. Please install Nix first:")
		fmt.Println("  curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install")
		return false
	}
	printSuccess("Nix is installed")
	return true
}

func detectShell() string {
	shell := os.Getenv("SHELL")
	if shell == "" {
		// Fallback if SHELL is not set, though less reliable
		// This is a simplistic check; a more robust one might involve checking parent processes
		// or using other OS-specific methods.
		printWarning("SHELL environment variable not set, attempting fallback detection.")
		// For now, we'll assume bash or sh as a common default if SHELL is not set.
		// A more sophisticated check could be added here if needed.
		return "bash" // Or return "unknown" and handle it
	}

	if strings.Contains(shell, "zsh") {
		return "zsh"
	} else if strings.Contains(shell, "bash") {
		return "bash"
	}
	// Add more shell detections if needed (e.g., fish)
	printWarning(fmt.Sprintf("Unsupported shell: %s. Defaulting to .profile for config.", shell))
	return "unknown"
}

func getShellConfig() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("could not get user home directory: %w", err)
	}

	shellType := detectShell()
	switch shellType {
	case "zsh":
		return filepath.Join(homeDir, ".zshrc"), nil
	case "bash":
		return filepath.Join(homeDir, ".bashrc"), nil
	default: // unknown or other shells
		// Fallback to .profile, which is often sourced by various shells
		return filepath.Join(homeDir, ".profile"), nil
	}
}

func main() {
	printHeader()
	if !checkNix() {
		os.Exit(1)
	}

	shellConfigPath, err := getShellConfig()
	if err != nil {
		printError(fmt.Sprintf("Failed to determine shell config path: %s", err))
		os.Exit(1)
	}
	printSuccess(fmt.Sprintf("Detected shell config file: %s", shellConfigPath))

	flakeRef := determineFlakeRef()
	// For now, just print the determined flake ref
	printSuccess(fmt.Sprintf("Using flake reference: %s", flakeRef))

	// Example of how to use the template (will be used in installDevFunctions later)
	// functionsContent := fmt.Sprintf(devFunctionsTemplate, DevFunctionsStartMarker, flakeRef, flakeRef, flakeRef, DevFunctionsEndMarker)
	// fmt.Println("\n--- Generated Shell Functions ---")
	// fmt.Println(functionsContent)
	// fmt.Println("--- End Generated Shell Functions ---")

	fmt.Println("\nFurther implementation coming soon...")

	err = installDevFunctions(shellConfigPath, flakeRef)
	if err != nil {
		printError(fmt.Sprintf("Failed to install dev functions: %s", err))
		os.Exit(1)
	}

	createGlobalScriptIfNeeded()

	fmt.Println()
	printSuccess("Installation complete!")
	fmt.Println()
	fmt.Printf("%sNext steps:%s\n", ColorYellow, ColorNC)
	fmt.Printf("1. Restart your terminal or run: source %s\n", shellConfigPath)
	fmt.Println("2. Test with: dev-list")
	fmt.Println("3. Enter a dev shell: dev-rust") // Example
	fmt.Println()
	fmt.Printf("%sFor maximum portability:%s\n", ColorYellow, ColorNC)
	fmt.Println("1. Push your flake to GitHub (if using remote flake)")
	fmt.Println("2. Ensure GITHUB_REPO in the Go program's constants is correct (if using remote flake)")
	fmt.Println("3. Share this compiled 'dev-env-installer-go' binary with others!")
}

const globalDevScriptContent = `#!/usr/bin/env bash
# Global dev environment launcher
# This script sources your primary shell configuration to make 'dev' functions available.

# Attempt to source shell configurations in a common order
if [ -f "$HOME/.zshrc" ]; then
    source "$HOME/.zshrc"
elif [ -f "$HOME/.bashrc" ]; then
    source "$HOME/.bashrc"
elif [ -f "$HOME/.profile" ]; then
    source "$HOME/.profile"
else
    echo "Error: Could not find .zshrc, .bashrc, or .profile to source." >&2
    exit 1
fi

# Execute the dev function with all passed arguments
dev "$@"
`

func createGlobalScriptIfNeeded() {
	scriptPath := "/usr/local/bin/dev-env"

	// Check if sudo is available and if we are not already root
	canSudo := false
	if _, err := exec.LookPath("sudo"); err == nil {
		canSudo = true
	}

	if os.Geteuid() == 0 { // Already root
		err := os.WriteFile(scriptPath, []byte(globalDevScriptContent), 0755)
		if err != nil {
			printError(fmt.Sprintf("Failed to write global script %s: %s", scriptPath, err))
			return
		}
		printSuccess(fmt.Sprintf("Global 'dev-env' command installed at %s", scriptPath))
	} else if canSudo {
		if promptUserYesNo(fmt.Sprintf("Install global 'dev-env' command to %s? (requires sudo)", scriptPath)) {
			cmd := exec.Command("sudo", "tee", scriptPath)
			cmd.Stdin = strings.NewReader(globalDevScriptContent)
			
			// Capture output for better error reporting
			var outb, errb bytes.Buffer
			cmd.Stdout = &outb
			cmd.Stderr = &errb

			err := cmd.Run()
			if err != nil {
				printError(fmt.Sprintf("Failed to write global script with sudo: %s", err))
				printError(fmt.Sprintf("Stderr: %s", errb.String()))
				return
			}

			// After writing, make it executable with sudo
			chmodCmd := exec.Command("sudo", "chmod", "+x", scriptPath)
			var chmodErrb bytes.Buffer
			chmodCmd.Stderr = &chmodErrb
			if err := chmodCmd.Run(); err != nil {
				printError(fmt.Sprintf("Failed to make global script executable with sudo: %s", err))
				printError(fmt.Sprintf("Stderr: %s", chmodErrb.String()))
				return
			}
			printSuccess(fmt.Sprintf("Global 'dev-env' command installed at %s", scriptPath))
		} else {
			printWarning("Skipping installation of global 'dev-env' command.")
		}
	} else {
		printWarning(fmt.Sprintf("Cannot install global 'dev-env' command to %s (sudo not found or not root). Functions will be available in your shell after sourcing.", scriptPath))
	}
}

func promptUserYesNo(promptMessage string) bool {
	fmt.Printf("%s%s (y/N): %s", ColorYellow, promptMessage, ColorNC)
	reader := bufio.NewReader(os.Stdin)
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(strings.ToLower(input))
	return input == "y" || input == "yes"
}

func installDevFunctions(shellConfigPath string, flakeRef string) error {
	contentBytes, err := os.ReadFile(shellConfigPath)
	if err != nil {
		// If the file doesn't exist, we can create it.
		if !os.IsNotExist(err) {
			return fmt.Errorf("failed to read shell config file %s: %w", shellConfigPath, err)
		}
		printWarning(fmt.Sprintf("Shell config file %s does not exist. It will be created.", shellConfigPath))
		contentBytes = []byte{}}
	content := string(contentBytes)

	startIndex := strings.Index(content, DevFunctionsStartMarker)
	endIndex := strings.Index(content, DevFunctionsEndMarker)

	newFunctions := fmt.Sprintf(devFunctionsTemplate, DevFunctionsStartMarker, flakeRef, flakeRef, flakeRef, DevFunctionsEndMarker)

	if startIndex != -1 && endIndex != -1 && startIndex < endIndex {
		printWarning(fmt.Sprintf("Dev environment functions already found in %s", shellConfigPath))
		if promptUserYesNo("Do you want to reinstall?") {
			// Remove existing block
			content = content[:startIndex] + content[endIndex+len(DevFunctionsEndMarker):]
			// Ensure there's a newline before appending, and trim existing newlines to avoid too many blanks
			content = strings.TrimRight(content, "\n") + "\n" + newFunctions
			printSuccess("Reinstalling dev functions.")
		} else {
			printSuccess("Skipping reinstallation.")
			return nil
		}
	} else {
		// Append new functions, ensuring a newline if content is not empty and doesn't end with one
		if len(content) > 0 && !strings.HasSuffix(content, "\n") {
			content += "\n"
		}
		content += newFunctions
	}

	err = os.WriteFile(shellConfigPath, []byte(content), 0644)
	if err != nil {
		return fmt.Errorf("failed to write updated shell config file %s: %w", shellConfigPath, err)
	}

	printSuccess(fmt.Sprintf("Dev environment functions installed in %s", shellConfigPath))
	return nil
}

func determineFlakeRef() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		printWarning(fmt.Sprintf("Could not get user home directory: %s. Defaulting to remote flake.", err))
		return "github:" + DefaultGithubRepo
	}

	localFlakePath := filepath.Join(homeDir, LocalFlakeDirName)
	localFlakeFile := filepath.Join(localFlakePath, "flake.nix")

	if _, err := os.Stat(localFlakeFile); err == nil {
		printSuccess(fmt.Sprintf("Using local flake at %s", localFlakePath))
		return localFlakePath
	} else {
		printWarning(fmt.Sprintf("Local flake not found at %s, will use remote: github:%s", localFlakePath, DefaultGithubRepo))
		printWarning("Make sure GITHUB_REPO in the script/constants is correct if you intend to use a remote flake!")
		return "github:" + DefaultGithubRepo
	}
}
